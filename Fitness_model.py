#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Oct 16 14:35:15 2018

@author: angela-kirykowicz
"""

import random
import json
import numpy as np
import matplotlib.pyplot as plt
import math as m
import statistics as s
from pylab import figure, axes, pie, title, show

def ran_dna_seq(r,n):
    """
    Function generates n random dna sequences of length r.
    Choose length as multiple of 3.
    """
    s = ''
    count = 0
    d = {0:'A', 1:'T', 2:'C', 3:'G'}
    dna_seq_list = []
    # Generates random DNA sequences and stores them in a list
    while count < n: #Set number of random sequences
        s = 'ATG' #start codon
        for letter in range(3,r): #Set length of sequence
            num = random.randint(0,3)
            s += str(d[num])
        dna_seq_list.append(s)
        count += 1
    return dna_seq_list


def ran_prot_seq(r,n):
    """
    Function generates n random protein sequences of length r.
    """
    prot_d = {0:'M', 1:'A', 2:'V', 3:'P', 4:'N', 5:'R', 6:'H', 7:'W', 8:'Y', 9:'G', 10:'S', 11:'T', 12:'D', 13:'K', 14:'Q', 15:'I', 16:'L', 17:'E', 18:'F', 19:'C'}
    count = 0
    prot_s = ''
    prot_seq_list = []
    while count < n:
        prot_s = 'M'
        for letter in range(1,r):
            num = random.randint(0,19)
            prot_s += str(prot_d[num])
        prot_seq_list.append(prot_s)
        count += 1
    return prot_seq_list



#General fitness assignment function
fit_dic = {'A':1, 'T':0,'G':1,'C':0} #Fix fitness values
def fit_assign(func,fit_dic):
    fit_assign_dic = {}
    for seq in func: #loops over seq list generated by ran_dna_seq function
        fit_sum = 0
        fit_prob = 0
        for elem in seq: #loops over each seq element
            fit_sum += fit_dic[elem] #sums each fitness assignment over seq
        fit_prob = round((1/len(seq)) * fit_sum,3) #calculates prob for seq
        fit_assign_dic[seq] = fit_prob #assigns seq prob to dictionary
    return fit_assign_dic

prot_fit_dic = {'M':1, 'A':0, 'V':1, 'P':0, 'N':1, 'R':1, 'H':0, 'W':1, 'Y':1, 'G':0, 'S':1, 'T':0, 'D':1, 'K':1, 'Q':1, 'I':0, 'L':1, 'E':0, 'F':0, 'C':1}
def prot_fit_assign(prot_func,prot_fit_dic):
    prot_fit_assign_dic = {}
    for seq in prot_func: #loops over seq list generated by ran_dna_seq function
        fit_sum = 0
        fit_prob = 0
        for elem in seq: #loops over each seq element
            fit_sum += prot_fit_dic[elem] #sums each fitness assignment over seq
        fit_prob = round((1/len(seq)) * fit_sum,3) #calculates prob for seq
        prot_fit_assign_dic[seq] = fit_prob #assigns seq prob to dictionary
    return prot_fit_assign_dic

#Initial Fitness Assignment
#ran_seq = ran_dna_seq(21,10)
#ran_seq_fit = fit_assign(ran_seq,fit_dic) #set initial fitness of population

n = 100 #number of initial sequences
#Kill member with lowest fitness
def remove_member(assign):
    """
    Function removes sequences with lowest fitness from assign dictionary
    """
    assign_copy = assign.copy()
    max_fit = max(assign.values())
    min_fit = min(assign.values())
    count = 0
    x = n
    new_assign_dic = {}
    for key,value in list(assign_copy.items()):
        if count < x:
            if float(value) > min_fit:
                new_assign_dic[key] = value
            elif min_fit == max_fit:
                new_assign_dic[key] = value
            count += 1
    return new_assign_dic


#Decide reproduction seq
def reproduction(assign):
    """
    Function takes sequences with highest fitness and adds it to another dictionary
    """
    highest_fit_dic = {}
    max_fit = max(assign.values()) #maximum fitness is highest fitness value
    for key,value in list(assign.items()):
        if float(value) == max_fit:
            highest_fit_dic[key] = value
    return highest_fit_dic


#Mutate seq with highest fit
dna_dic = {0:'A', 1:'T', 2:'C', 3:'G'} #dictionary of nucleotides
#mut_seq = reproduction_first_seq(assign) #sequences to mutate (highest fitness)
def mutate_seq(mut_seq):
    """
    Function mutates members from input function. 
    One random mutation per sequence randomly along the sequence.
    """ 
    mutate_seq_list = [] 
    for key in mut_seq.keys():
        #print(key)
        list_key = list(key)
        #print(list_key)
        num = random.randint(0,len(list_key))
        #print(num)
        mut_num = random.randint(0,3)
        #print(mut_num)
        for i,j in enumerate(list_key):
            if i == num:
                j = dna_dic[mut_num]
                list_key[i] = j
               # print(list_key)
                string_key = "".join(list_key)
               # print(string_key)
                mutate_seq_list.append(string_key)
    return mutate_seq_list


prot_dic = {0:'M', 1:'A', 2:'V', 3:'P', 4:'N', 5:'R', 6:'H', 7:'W', 8:'Y', 9:'G', 10:'S', 11:'T', 12:'D', 13:'K', 14:'Q', 15:'I', 16:'L', 17:'E', 18:'F', 19:'C'}
def prot_mutate_seq(prot_seq):
    """
    Function randomly mutates a protein sequence
    """
    prot_mutate_seq_list = []
    for key in prot_seq.keys():
        prot_list_key = list(key)
        prot_num = random.randint(1,len(prot_list_key)) #start methionine never mutated
        prot_mut_num = random.randint(0,19)
        for i,j in enumerate(prot_list_key):
            if i == prot_num:
                j = prot_dic[prot_mut_num]
                prot_list_key[i] = j
                prot_string_key = "".join(prot_list_key)
                prot_mutate_seq_list.append(prot_string_key)
    return prot_mutate_seq_list



#Recalculate fitness of mutated seq

#recalc_fit = mutate_seq(mut_seq)
#fit_assign(recalc_fit,fit_dic)


#Fill population with members of highest fitness (both mutated and not)

#new_population = assign.update(string_key)

#Implement keeping track of generations
#seq_len_dic = {}

def dna_fit_model(r,n,sim,gen):
    """
    Function implements dna fitness model.
    Set length of sequence (r), pop size (n), number of simulations to run (sim), and 
    number of generations (gen)
    """
    num_sim = 0
    max_fit = []
    min_fit = []
    sim_round = {}
    while num_sim < sim: #run simulation n times
#seq_len = []
        #print("simulation ", num_sim)
        gen_count = 0 #initial random sequences
        gen_dic_seq = {}
        gen_dic_fit = {}
        pop_seq = []
        pop_fit = []
        init_seq = ran_dna_seq(r,n) #up to 100 seq per gen
        #print("initial sequences are ",init_seq)
        init_fit = fit_assign(init_seq,fit_dic)
        for key, value in init_fit.items():
            pop_seq.append(key)
            pop_fit.append(value) 
        gen_dic_seq[gen_count] = pop_seq
        gen_dic_fit[gen_count] = pop_fit
        #print("initial fitnesses are ",init_fit)  
        rem = remove_member(init_fit)
        #print("initial pop is ", rem)
        gen_count += 1
        while gen_count < gen:   #initially run it for 10 generations
            pop_seq = []
            pop_fit = []
            rep = reproduction(rem)
            #print("generation ", gen_count, " sequences to reproduce are ",rep)
            mut = mutate_seq(rep)
            #print("generation ", gen_count, " new mutated sequences are ", mut)
            new_fit = fit_assign(mut,fit_dic)
            #print("generation ", gen_count, " new sequence fitnesses are ", new_fit)
            rem.update(new_fit)
            rem = remove_member(rem)
            #print("generation ", gen_count, " new population is ", rem)
            for key, value in rem.items():
                pop_seq.append(key)
                pop_fit.append(value) 
            gen_dic_seq[gen_count] = pop_seq
            gen_dic_fit[gen_count] = pop_fit
            gen_count += 1
  #  seq_len.append(gen_dic_seq)
   # seq_len.append(gen_dic_fit)
   # seq_len_dic[n] = seq_len
   # n += 1

        x = []
        for key in gen_dic_fit.keys():
            x.append(key)
        y = []
        i = 0
        for key,value in gen_dic_fit.items():
            if key == i:
                mean = round(s.mean(value),3)
            y.append(mean)
            i += 1
    
   # sim_round[num_sim] = gen_dic_fit
        plt.plot(x,y); plt.xlabel("Generation"); plt.ylabel("Average Fitness")
        num_sim +=1
    
    
    #plt.savefig("5_sims_len_300_100_seq_per_gen_1000_gen_T_and_C_0_fit.png", dpi=300)
#aver_fit_dic = {}
#i = 0
#j = 0

#for key, value in sim_round.items():
#    if key == j:
#        collect_mean = []
#        for s_key, s_value in value.items():
#            print(s_key,s_value)
#            if s_key == i:
#                print(s_key)
#                mean = round(s.mean(s_value),3)
#                print(mean)
#                collect_mean.append(mean)
#                print(collect_mean)
#            i += 1
#        aver_fit_dic[s_key] = collect_mean
#        j += 1

#plt.savefig('fit_model_20_runs.png', dpi=300)

#with open('fit_model_1', 'w') as f:
#    json.dump(seq_len_dic,f)
    

def prot_fit_model(r,n,sim,gen):
    """
    Function implements protein fitness model.
    Set length of sequence (r), pop size (n), number of simulations to run (sim), and 
    number of generations (gen)
    """
    num_sim = 0
    max_fit = []
    min_fit = []
    sim_round = {}
    while num_sim < sim: #run simulation n times
#seq_len = []
        print("simulation ", num_sim)
        gen_count = 0 #initial random sequences
        prot_gen_dic_seq = {}
        prot_gen_dic_fit = {}
        prot_pop_seq = []
        prot_pop_fit = []
        prot_init_seq = ran_prot_seq(r,n) #up to 100 seq per gen
        print("initial sequences are ",prot_init_seq)
        prot_init_fit = prot_fit_assign(prot_init_seq,prot_fit_dic)
        for key, value in prot_init_fit.items():
            prot_pop_seq.append(key)
            prot_pop_fit.append(value) 
        prot_gen_dic_seq[gen_count] = prot_pop_seq
        prot_gen_dic_fit[gen_count] = prot_pop_fit
        print("initial fitnesses are ",prot_init_fit)  
        prot_rem = remove_member(prot_init_fit)
        print("initial pop is ", prot_rem)
        gen_count += 1
        while gen_count < gen:   #initially run it for 10 generations
            prot_pop_seq = []
            prot_pop_fit = []
            prot_rep = reproduction(prot_rem)
            print("generation ", gen_count, " sequences to reproduce are ",prot_rep)
            prot_mut = prot_mutate_seq(prot_rep)
            print("generation ", gen_count, " new mutated sequences are ", prot_mut)
            prot_new_fit = prot_fit_assign(prot_mut,prot_fit_dic)
            print("generation ", gen_count, " new sequence fitnesses are ", prot_new_fit)
            prot_rem.update(prot_new_fit)
            prot_rem = remove_member(prot_rem)
            print("generation ", gen_count, " new population is ", prot_rem)
            for key, value in prot_rem.items():
                prot_pop_seq.append(key)
                prot_pop_fit.append(value) 
            prot_gen_dic_seq[gen_count] = prot_pop_seq
            prot_gen_dic_fit[gen_count] = prot_pop_fit
            gen_count += 1
  #  seq_len.append(gen_dic_seq)
   # seq_len.append(gen_dic_fit)
   # seq_len_dic[n] = seq_len
   # n += 1

        x = []
        for key in prot_gen_dic_fit.keys():
            x.append(key)
        y = []
        i = 0
        for key,value in prot_gen_dic_fit.items():
            if key == i:
                mean = round(s.mean(value),3)
            y.append(mean)
            i += 1
    
   # sim_round[num_sim] = gen_dic_fit
        plt.plot(x,y); plt.xlabel("Generation"); plt.ylabel("Average Fitness")
        num_sim +=1 
   # plt.savefig("protein_model_diff_fit_5_sims_len_100_100_seq_per_gen_100_gen.png", dpi=300)
    
    
    
    
    
    
    